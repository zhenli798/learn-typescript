(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{419:function(_,v,t){"use strict";t.r(v);var s=t(1),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-模型检验概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型检验概述"}},[_._v("#")]),_._v(" 1. 模型检验概述")]),_._v(" "),v("p",[_._v("面临的问题：代码缺陷总是不可避免，但代码缺陷往往会带来灾难性的后果。")]),_._v(" "),v("p",[_._v("模型检验的作用：使用计算机自动寻找软硬件代码缺陷。")]),_._v(" "),v("p",[_._v("模型检验方法可以分为以下三个部分：")]),_._v(" "),v("ul",[v("li",[_._v("建模")]),_._v(" "),v("li",[_._v("规约")]),_._v(" "),v("li",[_._v("算法")])]),_._v(" "),v("img",{attrs:{src:_.$withBase("/article/002/1.jpg"),alt:"modelcheck"}}),_._v(" "),v("center",[_._v("图1 模型检验过程")]),_._v(" "),v("h2",{attrs:{id:"_2-系统行为建模"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-系统行为建模"}},[_._v("#")]),_._v(" 2. 系统行为建模")]),_._v(" "),v("p",[_._v("        为实现自动验证，需要有一种支持推理的模型来对系统行为建模。迁移系统（Transition systems）是表示程序的一种标准模型，其本质是标记图（labeled graphs），其中标记可以是在节点或者边上。目前有很多迁移系统的各种不同变种。这里主要介绍Kripke结构、公平离散系统、以及Büchi自动机。")]),_._v(" "),v("h3",{attrs:{id:"_2-1-kripke结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-kripke结构"}},[_._v("#")]),_._v(" 2.1 Kripke结构")]),_._v(" "),v("p",[_._v("        Kripke结构是模型检验中表示迁移系统的一种最流行的结构之一。Kripke结构是一个有向图，"),v("font",{attrs:{color:"red"}},[_._v("该图中的每个节点都用一些原子命题标记")]),_._v("。该图中的节点和边分别称为“状态”和“迁移”。该结构的本质是"),v("code",[_._v("状态标记迁移系统")])],1),_._v(" "),v("ol",[v("li",[v("strong",[_._v("定义1（Kripke结构）")])])]),_._v(" "),v("p",[_._v("用五元组K=〈AP,S,S"),v("sub",[_._v("0")]),_._v(",R,L〉来表示一个Kripke结构，其中：")]),_._v(" "),v("ul",[v("li",[_._v("AP是一个有限的原子命题集合")]),_._v(" "),v("li",[_._v("S是一个有限的状态集合")]),_._v(" "),v("li",[_._v("S"),v("sub",[_._v("0")]),_._v("表初始状态集合(S"),v("sub",[_._v("0")]),_._v("⊆S)")]),_._v(" "),v("li",[_._v("R表示迁移关系")]),_._v(" "),v("li",[_._v("L是一个标记函数，标记每一个状态上成立的原子命题。例L(s)表示在状态s上成立的原子命题集合。")])]),_._v(" "),v("p",[_._v("例子：电梯运行问题的Kripke结构")]),_._v(" "),v("img",{attrs:{src:_.$withBase("/article/002/2.png"),alt:"elevator"}}),_._v(" "),v("ul",[v("li",[_._v("AP={a, b, c}，其中a, b, c是三个原子命题，分别表示电梯往上运行、电梯停止和电梯往下运行")]),_._v(" "),v("li",[_._v("S={up, stop, down}")]),_._v(" "),v("li",[_._v("S"),v("sub",[_._v("0")]),_._v("={stop}")]),_._v(" "),v("li",[_._v("R={(stop, up),(up, stop),(stop, down),(down, stop)}")]),_._v(" "),v("li",[_._v("L(stop)={b}, L(up)={a}, L(down)={c}，分别表示在stop状态中电梯停止，在up状态中电梯往上运行，在down状态中电梯往下运行。")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("strong",[_._v("定义2（路径）")])])]),_._v(" "),v("p",[_._v("        一条路径（Path）是指从某个状态s∈S出发的一条最长的状态序列σ=s"),v("sub",[_._v("0")]),_._v(",s"),v("sub",[_._v("1")]),_._v(",s"),v("sub",[_._v("2")]),_._v("⋯，其中s"),v("sub",[_._v("0")]),_._v(" = s，并且对任意的i ≥ 0，有(s"),v("sub",[_._v("i")]),_._v(", s"),v("sub",[_._v("i+1")]),_._v(")∈R。\nσ是一个最长的状态序列是指𝜎包含无限个状态，或者𝜎的最后一个状态没有后继状态。")]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("strong",[_._v("定义3（执行）")])])]),_._v(" "),v("p",[_._v("给定一个Kripke结构K=〈AP, S, S"),v("sub",[_._v("0")]),_._v(", R, L〉，一个执行（Run）是指从某个初始状态s"),v("sub",[_._v("0")]),_._v("∈S"),v("sub",[_._v("0")]),_._v("出发的一条路径σ。")]),_._v(" "),v("p",[_._v("        基于离散状态变化的相关模型有时也被称为自动机（automata）、状态机（state machines）、状态图（state diagrams）、标记迁移系统（labeled transition systems）等。在很多情况下，一个检测算法很容易在这些模型之间进行移植。")]),_._v(" "),v("h2",{attrs:{id:"_3-模型检验算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-模型检验算法"}},[_._v("#")]),_._v(" 3. 模型检验算法")]),_._v(" "),v("h3",{attrs:{id:"_3-1-显示状态模型检验"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-显示状态模型检验"}},[_._v("#")]),_._v(" 3.1 显示状态模型检验")]),_._v(" "),v("p",[_._v("显示状态模型检验（Explicit-State Model Checking）是"),v("font",{attrs:{color:"red"}},[_._v("最早的")]),_._v("模型检验算法之一。")],1),_._v(" "),v("ul",[v("li",[_._v("它显示地枚举系统的每一个状态或路径，判断属性是否在每一个状态或每一条路径上都成立")]),_._v(" "),v("li",[_._v("特别适合于软件的验证，尤其是异步软件系统的验证")]),_._v(" "),v("li",[_._v("在显示状态模型检验中可以使用"),v("font",{attrs:{color:"red"}},[_._v("抽象（abstract）技术")]),_._v("和"),v("font",{attrs:{color:"red"}},[_._v("偏序规约技术（Partial Order Reduction）")]),_._v("进行剪枝，显著的减少其搜索空间")],1),_._v(" "),v("li",[_._v("可用于安全属性和活性属性的验证")])]),_._v(" "),v("p",[v("strong",[_._v("显示状态模型检验需要满足的几个条件")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("待验证系统必须是有限状态的")]),_._v(" "),v("li",[_._v("可以将系统执行建模为一系列独立的状态转换")])]),_._v(" "),v("p",[_._v("        下面以可达性分析算法为例，介绍基本的显示状态模型检验方法。基本的可达性分析算法可以实现为深度优先搜索算法或宽度优先搜索算法。该算法从系统的初始状态开始，对系统的所有可达状态进行搜索。")]),_._v(" "),v("h3",{attrs:{id:"_3-2-基于约束求解的模型检验"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-基于约束求解的模型检验"}},[_._v("#")]),_._v(" 3.2 基于约束求解的模型检验")])],1)}),[],!1,null,null,null);v.default=a.exports}}]);
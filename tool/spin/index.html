<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SPIN工具的安装与使用 | 小陌白学习笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/vuepress-notes/logo.jpeg">
    <meta name="description" content="记录日常学习">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/vuepress-notes/assets/css/0.styles.e49afd74.css" as="style"><link rel="preload" href="/vuepress-notes/assets/js/app.80219140.js" as="script"><link rel="preload" href="/vuepress-notes/assets/js/3.4410d185.js" as="script"><link rel="preload" href="/vuepress-notes/assets/js/1.04063a12.js" as="script"><link rel="preload" href="/vuepress-notes/assets/js/19.5ee5dec0.js" as="script"><link rel="prefetch" href="/vuepress-notes/assets/js/10.38747bdd.js"><link rel="prefetch" href="/vuepress-notes/assets/js/11.0ec256ee.js"><link rel="prefetch" href="/vuepress-notes/assets/js/12.df08fd51.js"><link rel="prefetch" href="/vuepress-notes/assets/js/13.241ff02a.js"><link rel="prefetch" href="/vuepress-notes/assets/js/14.da6e2a0f.js"><link rel="prefetch" href="/vuepress-notes/assets/js/15.4562ebb9.js"><link rel="prefetch" href="/vuepress-notes/assets/js/16.52832b2c.js"><link rel="prefetch" href="/vuepress-notes/assets/js/17.a042ce30.js"><link rel="prefetch" href="/vuepress-notes/assets/js/18.2b4d953c.js"><link rel="prefetch" href="/vuepress-notes/assets/js/4.ceb255ee.js"><link rel="prefetch" href="/vuepress-notes/assets/js/5.ed69fae2.js"><link rel="prefetch" href="/vuepress-notes/assets/js/6.71ccba96.js"><link rel="prefetch" href="/vuepress-notes/assets/js/7.8e4cedf0.js"><link rel="prefetch" href="/vuepress-notes/assets/js/8.22a17f27.js"><link rel="prefetch" href="/vuepress-notes/assets/js/9.29a1a10b.js">
    <link rel="stylesheet" href="/vuepress-notes/assets/css/0.styles.e49afd74.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>小陌白学习笔记</h3> <p class="description" data-v-59e6cb88>记录日常学习</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>小陌白</span>
          
        <span data-v-59e6cb88>2022 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-notes/" class="home-link router-link-active"><img src="/vuepress-notes/logo.jpeg" alt="小陌白学习笔记" class="logo"> <span class="site-name">小陌白学习笔记</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-notes/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><a href="/vuepress-notes/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/vuepress-notes/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      文献阅读
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/article/article001/" class="nav-link"><i class="undefined"></i>
  形式化方法的研究进展与趋势
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/article/article002/" class="nav-link"><i class="undefined"></i>
  模型检验理论
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      工具
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/spin/" aria-current="page" class="nav-link router-link-exact-active router-link-active"><i class="undefined"></i>
  SPIN
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/nusmv/" class="nav-link"><i class="undefined"></i>
  NuSMV
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/aadl/" class="nav-link"><i class="undefined"></i>
  AADL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      学习笔记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/english/" class="nav-link"><i class="undefined"></i>
  英语学习
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/django/" class="nav-link"><i class="undefined"></i>
  Django学习
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/ocaml/" class="nav-link"><i class="undefined"></i>
  OCaml学习
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      我的其他平台
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhenli798" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_48842132" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepress-notes/avator.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    小陌白
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>9</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>6</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-notes/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><a href="/vuepress-notes/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/vuepress-notes/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      文献阅读
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/article/article001/" class="nav-link"><i class="undefined"></i>
  形式化方法的研究进展与趋势
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/article/article002/" class="nav-link"><i class="undefined"></i>
  模型检验理论
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      工具
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/spin/" aria-current="page" class="nav-link router-link-exact-active router-link-active"><i class="undefined"></i>
  SPIN
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/nusmv/" class="nav-link"><i class="undefined"></i>
  NuSMV
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/tool/aadl/" class="nav-link"><i class="undefined"></i>
  AADL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      学习笔记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/english/" class="nav-link"><i class="undefined"></i>
  英语学习
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/django/" class="nav-link"><i class="undefined"></i>
  Django学习
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-notes/daily/ocaml/" class="nav-link"><i class="undefined"></i>
  OCaml学习
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-other"></i>
      我的其他平台
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhenli798" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_48842132" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vuepress-notes/" class="sidebar-heading clickable router-link-active"><span>🛖‍ 个人中心</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-notes/" aria-current="page" class="sidebar-link">个人主页</a></li><li><a href="/vuepress-notes/todo.html" class="sidebar-link">待办事项</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vuepress-notes/article/article001/" class="sidebar-heading clickable"><span>📚 文献阅读</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-notes/article/article001/" class="sidebar-link">形式化方法的研究进展与趋势</a></li><li><a href="/vuepress-notes/article/article002/" class="sidebar-link">模型检验理论</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vuepress-notes/tool/spin/" aria-current="page" class="sidebar-heading clickable router-link-exact-active router-link-active open active"><span>🔧 工具</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-notes/tool/spin/" aria-current="page" class="active sidebar-link">SPIN</a></li><li><a href="/vuepress-notes/tool/nusmv/" class="sidebar-link">NuSMV</a></li><li><a href="/vuepress-notes/tool/aadl/" class="sidebar-link">AADL</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vuepress-notes/daily/english/" class="sidebar-heading clickable"><span>📝 ️学习笔记</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-notes/daily/english/" class="sidebar-link">英语学习</a></li><li><a href="/vuepress-notes/daily/django/" class="sidebar-link">Django学习</a></li><li><a href="/vuepress-notes/daily/ocaml/" class="sidebar-link">OCaml学习</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>SPIN工具的安装与使用</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>小陌白</span>
          
        <span data-v-59e6cb88>2022 - </span>
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">SPIN工具的安装与使用</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>小陌白</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2022/10/24</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>模型检验</span><span class="tag-item" data-v-8a445198>形式化方法</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="_1-什么是spin"><a href="#_1-什么是spin" class="header-anchor">#</a> 1. 什么是Spin</h2> <blockquote><p>        Spin是一款广泛使用的开源软件验证工具，主要用于多线程软件应用的形式化验证。是一种用于分析分布式系统（特别是数据通信协议）的逻辑一致性的工具。
该工具使用Promela(Process or Protocol Meta Language)建模语言对系统进行建模。该语言允许动态创建并发进程。通过消息通道进行的通信可以定义为同步（即rendezvous）或异步（即buffered）。</p></blockquote> <h2 id="_2-spin功能特性"><a href="#_2-spin功能特性" class="header-anchor">#</a> 2. Spin功能特性</h2> <ol><li>旨在<code>有效验证多线程软件</code>，而不是硬件电路的验证</li> <li>支持使用<code>嵌入式C代码</code>作为模型规范的一部分</li> <li>支持使用<code>多核计算机进行并行的模型检验</code>——支持安全性和活性属性的验证</li> <li>采取<code>on-the-fly</code>的工作方式，可以不用在验证系统属性之前预先构建全局状态图或Kripke结构，使得验证非常大的系统模型成为可能</li> <li>可以用作<code>完整的LTL模型检验</code>工具，支持用线性时序逻辑（LTL）表达的所有属性的验证，但它也可以用作基本的安全性（safety）和活性（liveness）属性的高效on-the-fly验证器</li> <li>支持进程数量动态增加和缩小</li> <li>支持<code>会合（rendezvous）</code>和<code>缓冲消息传递（buffered message passing）</code>，以及通过<code>共享内存</code>进行通信。还支持同时使用<code>同步</code>和<code>异步</code>通信的混合系统。</li> <li>支持<code>随机</code>、<code>交互式</code>和<code>引导式</code>模拟，以及基于<code>深度优先搜索</code>、<code>广度优先搜索</code>或<code>有界上下文切换</code>的穷尽和部分证明技术。该工具旨在很好地扩展到，并高效处理大规模问题。</li> <li>该工具利用了<code>高效的偏序规约</code>技术和（可选）<code>类似 BDD 的状态存储</code>技术来优化验证运行。</li></ol> <p>        对一个设计进行验证时，需要使用Spin的输入语言PROMELA构建一个形式化的模型。PROMELA是一种非确定性语言，该语言基于Dijkstra的命令语言符号，并从Hoare的CSP语言中借用了I/O操作的相关符号。</p> <h2 id="_3-spin的四种主要使用模式"><a href="#_3-spin的四种主要使用模式" class="header-anchor">#</a> 3. Spin的四种主要使用模式</h2> <ol><li>作为<strong>模拟器</strong>，允许通过随机、引导或交互式模拟进行快速原型设计</li> <li>作为<strong>严格的验证工具</strong>，能够严格证明用户属性的正确性(使用偏序规约理论来优化搜索)</li> <li>作为<strong>近似证明系统</strong>，可以验证非常大的系统模型，并具有最大状态空间覆盖范围</li> <li>作为<strong>群验证</strong>(swarm verification，一种可以利用任意大小的云网络的新型群计算形式)的驱动引擎，可充分利用大量可用的计算内核来利用并行性和多样化搜索技术，从而增加在超大模型中的缺陷定位机会</li></ol> <h2 id="_4-spin的下载安装"><a href="#_4-spin的下载安装" class="header-anchor">#</a> 4. Spin的下载安装</h2> <p><font color="red">以在windows环境下为例：</font></p> <h3 id="_4-1-spin的下载安装"><a href="#_4-1-spin的下载安装" class="header-anchor">#</a> 4.1 Spin的下载安装</h3> <p>        点击<a href="https://spinroot.com/spin/Src/index.html" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下载pc_spin*.zip文件。从pc_spin*.zip中提取文件(若出现这种pc_spin*.zip文件则需要重命名为spin.exe)之后打开配置环境变量，将spin.exe所在的路径加入其中。</p> <p>        要运行Spin，也就是预编译版本，需要一个工作的C编译器和一个C预处理器，因为Spin将其模型检查软件生成为C源文件，这些文件需要在执行验证之前进行编译，故要确保已安装MinGW-w64。在命令行中输入<code>gcc -v</code>查询，出现下图反馈，说明gcc配置无误：
<img src="/vuepress-notes/tool/spin/1.png" alt="gcc">
下面使用<code>spin</code>查看spin.exe是否添加成功，如果出现以下信息，则说明系统变量已成功添加：
<img src="/vuepress-notes/tool/spin/2.png" alt="spin"></p> <h3 id="_4-2-ispin的下载安装"><a href="#_4-2-ispin的下载安装" class="header-anchor">#</a> 4.2 iSpin的下载安装</h3> <p>        iSpin是一个可选的，但强烈推荐的Spin的图形用户界面，用Tcl/Tk编写。要在PC上运行iSpin，需要Tcl/Tk的PC版本。点击<a href="https://www.activestate.com/products/tcl/" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下载安装ActiveTcl，
然后双击spin安装目录下的ispin.exe即可打开：
<img src="/vuepress-notes/tool/spin/3.png" alt="ispin"></p> <h3 id="_4-3-ispin的使用"><a href="#_4-3-ispin的使用" class="header-anchor">#</a> 4.3 iSpin的使用</h3> <p>新建一个plm文件，输入下列内容：</p> <div class="language-c extra-class"><pre class="language-c"><code>mtype <span class="token operator">=</span> <span class="token punctuation">{</span> ack<span class="token punctuation">,</span> nak<span class="token punctuation">,</span> err<span class="token punctuation">,</span> next<span class="token punctuation">,</span> accept <span class="token punctuation">}</span><span class="token punctuation">;</span>
proctype <span class="token function">transfer</span><span class="token punctuation">(</span>chan in<span class="token punctuation">,</span>out<span class="token punctuation">,</span> chin<span class="token punctuation">,</span> chout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>	byte o<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
	in<span class="token operator">?</span><span class="token function">next</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">do</span>
	<span class="token operator">::</span> chin<span class="token operator">?</span><span class="token function">nak</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
			out<span class="token operator">!</span><span class="token function">accept</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			chout<span class="token operator">!</span><span class="token function">ack</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
	<span class="token operator">::</span> chin<span class="token operator">?</span><span class="token function">ack</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
			out<span class="token operator">!</span><span class="token function">accept</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			in<span class="token operator">?</span><span class="token function">next</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
			chout<span class="token operator">!</span><span class="token function">ack</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
	<span class="token operator">::</span> chin<span class="token operator">?</span><span class="token function">err</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
			chout<span class="token operator">!</span><span class="token function">nak</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
	od
<span class="token punctuation">}</span>
init
<span class="token punctuation">{</span>	chan AtoB <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan BtoA <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan Ain  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan Bin  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan Aout <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan Bout <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> mtype<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>
	atomic <span class="token punctuation">{</span>
	  run <span class="token function">transfer</span><span class="token punctuation">(</span>Ain<span class="token punctuation">,</span>Aout<span class="token punctuation">,</span> AtoB<span class="token punctuation">,</span>BtoA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	  run <span class="token function">transfer</span><span class="token punctuation">(</span>Bin<span class="token punctuation">,</span>Bout<span class="token punctuation">,</span> BtoA<span class="token punctuation">,</span>AtoB<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	AtoB<span class="token operator">!</span><span class="token function">err</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在iSpin中使用open打开该文件，通过在 Edit/view标签中的 Syntax Check，Redundancy Check之后：
<img src="/vuepress-notes/tool/spin/4.png" alt="ispin">
通过 Simulate/Replay标签有(Re)Run， Stop 和 Rewind 等进行一个随机模拟的运行。其中中间左方白框为输入，左下方黑方框为变量数值，中间黑框是运行过程以及问题出错行：
<img src="/vuepress-notes/tool/spin/5.png" alt="ispin"></p> <h2 id="_5-基于promela的系统建模"><a href="#_5-基于promela的系统建模" class="header-anchor">#</a> 5. 基于Promela的系统建模</h2> <p>        Promela模型由3种类型的对象组成：进程、消息通道和变量。进程是全局对象。消息通道和变量可以声明为全局的或在进程内声明为本地的。
进程定义系统行为，消息通道和全局变量则定义进程运行的环境。</p> <p>        上面4.3就给出了一个promela的模型例子，该例子中定义了2个transfer进程，6个通道，每个进程中定义了2个byte类型的局部变量o和i。</p> <h3 id="_5-1-进程"><a href="#_5-1-进程" class="header-anchor">#</a> 5.1 进程</h3> <ol><li><strong>进程声明</strong></li></ol> <p>形式：</p> <div class="language-c extra-class"><pre class="language-c"><code>proctype <span class="token function">pname</span><span class="token punctuation">(</span>chan In<span class="token punctuation">,</span> Out<span class="token punctuation">;</span> byte id <span class="token punctuation">)</span>
<span class="token punctuation">{</span> statements <span class="token punctuation">}</span>
</code></pre></div><p>上述进程定义了一个进程类型pname，该进程参数包含两个消息通道In和Out，以及一个byte类型的参数id。
<font color="red">注：</font>在进程的声明中，<strong>相同类型的参数之间用“,”分隔，不同类型的参数之间用“;”分隔</strong>。进程体用一对{}括起来。</p> <p>例：下面的代码声明了两个进程类型A和B</p> <div class="language-c extra-class"><pre class="language-c"><code>byte state <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

proctype <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>	<span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> state <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span>

proctype <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>	state <span class="token operator">=</span> state <span class="token operator">-</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li><strong>进程实例化</strong></li></ol> <p>        进程声明仅仅是定义了一个进程类型的行为，但并不能执行。要执行进程需要先通过进程实例化实例化出一个真实的进程，称其为进程定义。
在promela中通过<code>run</code>操作来实例化进程。</p> <p>例：使用下面语句来将上面声明的两个进程类型实例化为真实的进程</p> <div class="language-c extra-class"><pre class="language-c"><code>run <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
run <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>每个进程实例都有一个唯一的实例编号，它由run操作符（和pid）产生。进程实例保持活跃状态，直到进程体结束。进程不能将数组作为形参类型，但允许使用结构体。</p> <ol start="3"><li><strong>进程声明的扩充</strong></li></ol> <p>进程声明可以通过多种方式进行扩充。最一般的形式是：</p> <div class="language-c extra-class"><pre class="language-c"><code>active <span class="token punctuation">[</span>N<span class="token punctuation">]</span> proctype <span class="token function">pname</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">provided</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> priority M
</code></pre></div><p>其中，active [N] 表示在初始系统状态就定义N个proctype的进程实例。其中N是一个常数。如果[N]不存在，则仅激活一个实例。通过active修饰符激活的实例的形参初始化为0。一个proctype 可以有一个与之关联的启用条件E，它是一个通用的表达式，表达式中可能包含常量、全局变量、预定义变量timeout和pid。启用条件在初始状态下进行计算。为了在随机模拟过程中使用，进程实例可以以优先级M运行，M是一个&gt;=1的常数。这样的进程被调度的可能性是默认（优先级 1）进程的M倍。</p> <p>执行优先级也可以在run语句中使用：</p> <div class="language-c extra-class"><pre class="language-c"><code>run <span class="token function">pname</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> priority M<span class="token punctuation">;</span>
</code></pre></div><p>使用run语句实例化的进程的默认优先级是1。<font color="red">注：</font><strong>优先级对分析过程是没有影响的</strong>。</p> <ol start="4"><li><strong>初始化进程</strong></li></ol> <p>        每个Promela模型都会显示地包含一个init进程，init进程主要用于初始化变量和执行适当的进程实例化来对系统进行初始化。init进程的定义方式：<code>init { statements }</code></p> <p>例如：</p> <div class="language-c extra-class"><pre class="language-c"><code>init
<span class="token punctuation">{</span>	
	run <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	run <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li><strong>Never claim</strong></li></ol> <p>        在promela中，使用never claims来描述不被期望或非法的行为，即希望永远不会发生的行为。Never claim的定义方式：<code>never { statements }</code></p> <p>        是promela中一种特殊的进程，如果存在，则实例化一次。
<strong>Never claim被定义为系统状态的一系列命题或布尔表达式</strong>，这些命题或布尔表达式必须按照指定的顺序变为真，以匹配感兴趣的行为。在spin中，never claim可以手写,也可以通过转换工具将LTL 公式转换得到。</p> <p>        如果模型中存在never claim，则系统和该claim将同时执行，即在每一步中都是系统执行一步，never claim进程执行一步。如果claim自动机没有可执行的迁移了，则沿着该路径的搜索将停止，然后回溯到别的执行路径继续搜索。</p> <p>        statements中的语句被解释为<font color="red">条件，因此不应有副作用</font>（尽管这将导致警告而不是语法错误）。因此，<font color="red">在never claim中不能使用赋值、自动递增和递减操作、通信、运行和断言语句等</font>。在never claim中可以使用下面三个函数以获取相应的信息：</p> <p>                1. enabled(pid)：如果进程pid能够执行操作，则此布尔函数返回true。该函数只能在不允许同步通信的系统中使用</p> <p>                2. pc_value(pid)：该函数返回进程pid当前所处的状态编号。（使用-d选项可以看到状态编号。）</p> <p>                3. _np：如果系统处于非进度状态，则此谓词为真，否则为假。引入它是为了更有效地搜索非进度周期。</p> <h3 id="_5-2-消息通道"><a href="#_5-2-消息通道" class="header-anchor">#</a> 5.2 消息通道</h3> <ol><li><strong>消息通道的定义</strong></li></ol> <p>        消息通道主要用于不同进程之间的数据传输。消息通道可以为全局或局部通道。通道名字可以作为消息的一部分通过另一个通道从一个进程传送到另一个进程，也可以在进程实例化时作为其实参传递给进程。</p> <p>消息通道定义的几种方式：</p> <div class="language-c extra-class"><pre class="language-c"><code>chan qname <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> <span class="token keyword">short</span> <span class="token punctuation">}</span>
chan transfer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> byte<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> chan<span class="token punctuation">,</span> byte <span class="token punctuation">}</span>
chan device <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span>byte<span class="token punctuation">}</span><span class="token punctuation">;</span>
chan channel<span class="token punctuation">;</span>
chan chanArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> <span class="token keyword">int</span> <span class="token punctuation">}</span>
</code></pre></div><p>在上述定义中：</p> <ul><li>qname定义了一个最多可以存储16条消息的通道，消息类型在大括号之中定义，每条消息都是一个short类型的数据。</li> <li>transfer定义了一个最多可以存储16条消息的通道，其中每条消息都包含2个byte类型的数据、1个int类型的数据、以及一个通道名称。</li> <li>device通道最多可以存储的消息数量为0，表示该通道不能存储消息。称这类通道为无缓冲通道，或同步通道。对无缓冲通道，因为消息不能存储，因此发送和接收必须同步，即若一个进程往该通道中发送数据，则同时必须有另一个进程从通道中接收数据。</li> <li>Channel是一个未初始化的通道，只有在分配了一个初始化的通道后才能使用它。</li> <li>chanArray定义了一个包含3个通道的通道数组，每个通道都是传送1个int数据的无缓冲通道。</li></ul> <p>        请注意，chan类型的对象可以是另一个通道中消息的一部分。给定一个通道qname，函数len(qname)返回该通道中现有的消息数量。</p> <ol start="2"><li><strong>消息的发送与接收</strong></li></ol> <ul><li>消息的发送：<code>qname!expr</code>，将expr表达式的值发送到通道qname中(一条消息发送操作只有在消息通道没有满的时候才是可执行的)</li> <li>消息的接收：<code>qname?msg</code>，从通道qname的开头位置接收一条消息存在变量msg中(一条消息接收操作只有在消息通道不是空的时候才是可执行的)</li> <li>发送或接收多个数据：</li></ul> <div class="language-c extra-class"><pre class="language-c"><code>qname<span class="token operator">!</span>expr1<span class="token punctuation">,</span>expr2<span class="token punctuation">,</span>expr3
qname<span class="token operator">?</span>var1<span class="token punctuation">,</span>var2<span class="token punctuation">,</span>var3
</code></pre></div><p><font color="red">若发送或接收的数据数量与通道定义中声明的消息数据不一致，将产生错误。</font></p> <p>        在消息的发送和接收操作中，第一个消息字段通常用于指定消息类型（一个常量）。因此，发送和接收操作的另一种表示法是先指定消息类型，后跟1对小括号，将传送的消息字段列表括起来，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>qname<span class="token operator">!</span><span class="token function">expr1</span><span class="token punctuation">(</span>expr2<span class="token punctuation">,</span>expr3<span class="token punctuation">)</span>
qname<span class="token operator">?</span><span class="token function">var1</span><span class="token punctuation">(</span>var2<span class="token punctuation">,</span>var3<span class="token punctuation">)</span>
</code></pre></div><p>        有些时候，接收操作的参数也可能是常量，如下所示。在这种情况下，一个消息接收操作可以执行还要求通道中待接收消息响应字段的值必须与相应的常量值相等。</p> <div class="language-c extra-class"><pre class="language-c"><code>qname<span class="token operator">?</span>cons1<span class="token punctuation">,</span>var2<span class="token punctuation">,</span>cons2
</code></pre></div><p>下面的例子中定义了两个进程和两个通道qname和qforb</p> <div class="language-c extra-class"><pre class="language-c"><code>proctype <span class="token function">A</span><span class="token punctuation">(</span>chan q1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>	chan q2<span class="token punctuation">;</span>
	q1<span class="token operator">?</span>q2<span class="token punctuation">;</span>
	q2<span class="token operator">!</span><span class="token number">123</span>
<span class="token punctuation">}</span>

proctype <span class="token function">B</span><span class="token punctuation">(</span>chan qforb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	qforb<span class="token operator">?</span>x<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;x = %d\n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

init <span class="token punctuation">{</span>
	chan qname <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> chan <span class="token punctuation">}</span><span class="token punctuation">;</span>
	chan qforb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> <span class="token keyword">int</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	run <span class="token function">A</span><span class="token punctuation">(</span>qname<span class="token punctuation">)</span><span class="token punctuation">;</span>
	run <span class="token function">B</span><span class="token punctuation">(</span>qforb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	qname<span class="token operator">!</span>qforb
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li><strong>同步通信</strong></li></ol> <p>        对于一个同步通道（无缓冲通道），其通道大小为0，因此该通道只能传送数据，而不能存储数据，因此对此类通道，其发送和接收操作必须同步执行。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">msgtype</span> <span class="token expression"><span class="token number">33</span></span></span>

chan name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span> byte<span class="token punctuation">,</span> byte <span class="token punctuation">}</span><span class="token punctuation">;</span>

proctype <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>	
	name<span class="token operator">!</span><span class="token function">msgtype</span><span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	name<span class="token operator">!</span><span class="token function">msgtype</span><span class="token punctuation">(</span><span class="token number">121</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

proctype <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>	
	byte state<span class="token punctuation">;</span>
	name<span class="token operator">?</span><span class="token function">msgtype</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

init
<span class="token punctuation">{</span>	
	atomic <span class="token punctuation">{</span> run <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> run <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面例子中，通道name是一个全局的同步通道，因此两个进程将同时执行他们的第一条语句，从而实现将124从进程A传递给进程B。进程A的第二条发送语句由于没有匹配的接收操作，因此是不可执行的。</p> <h3 id="_5-3-数据定义"><a href="#_5-3-数据定义" class="header-anchor">#</a> 5.3 数据定义</h3> <ol><li><strong>数据类型</strong></li></ol> <p>        Promela中的基本数据类型有bit、bool、byte、short或int，这些基本类型的位宽分别为 1、1、8、16 和 32。前三个是无符号类型，后两个是有符号类型。除此之外，常用的数据类型还有数组和用户自定义结构体等。<font color="red">Promela中没有浮点数。</font></p> <table><thead><tr><th>Promela数据类型</th> <th style="text-align:center;">等价的C类型</th> <th style="text-align:right;">取值范围</th></tr></thead> <tbody><tr><td>bit or bool</td> <td style="text-align:center;">位</td> <td style="text-align:right;">0..1</td></tr> <tr><td>byte</td> <td style="text-align:center;">Uchar</td> <td style="text-align:right;">0..255</td></tr> <tr><td>short</td> <td style="text-align:center;">Short</td> <td style="text-align:right;">-(2<sup>15</sup>-1)..(2<sup>15</sup>-1)</td></tr> <tr><td>int</td> <td style="text-align:center;">int</td> <td style="text-align:right;">-(2<sup>31</sup>-1)..(2<sup>31</sup>-1)</td></tr></tbody></table> <p>2.<strong>变量</strong></p> <p>        类似于C语言的变量定义，Promela中的变量必须先定义再使用，变量定义方式如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">&lt;</span>类型描述符<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>变量表<span class="token operator">&gt;</span>
</code></pre></div><p>例：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
bool x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
</code></pre></div><p>初始值(如果指定)<font color="red">必须是常量</font>。默认情况下，变量初始化为0。</p> <ol start="3"><li><strong>常量</strong></li></ol> <p>常量是表示十进制整数的数字序列。常用的常量定义方法是使用C风格的<font color="red">宏定义</font>，例：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NAME</span> <span class="token expression"><span class="token number">5</span></span></span>
</code></pre></div><ol start="4"><li><strong>数组</strong></li></ol> <p>数组变量的定义与C语言类似，如下所示。数组索引从 0 开始，因此，在下面的数组中，最大的索引是 3。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p><font color="red">与C中一样，数组可以有一个常量作为初始值，初始化所有数组元素。</font></p> <ol start="5"><li><strong>枚举类型</strong></li></ol> <p>枚举类型可以声明为：<code>mtype = {OK, READY, ACK}</code></p> <p>mtype是一个<font color="red">关键字</font>，<strong>只允许定义一个mtype枚举类型，且该类型定义是全局的</strong>，最多可以声明256个符号常量；mtype变量宽度为8位。该类型的变量可以声明为：<code>mtype Status = OK</code></p> <ol start="6"><li><strong>结构体</strong></li></ol> <p>用户定义的数据类型可以通过<code>typedef</code>定义：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> Msg <span class="token punctuation">{</span>
		byte a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">;</span>
		chan p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该类型可以在变量声明中使用，更一般地，可以在任何需要的地方使用：</p> <div class="language-c extra-class"><pre class="language-c"><code>Msg foo<span class="token punctuation">;</span>
chan stream <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> of <span class="token punctuation">{</span>mtype<span class="token punctuation">,</span>Msg<span class="token punctuation">}</span>
</code></pre></div><p>结构体成员的访问方式与C相同，如：<code>foo.a[1]</code></p> <ol start="7"><li><strong>特殊变量</strong></li></ol> <p>        Promela中有两个特殊变量_pid和_last。_pid是一个预定义的局部变量，用于保存进程实例的实例化编号。_last是一个预定义的全局变量，它保存在当前执行序列中执行最后一步的进程实例的编号。初始时，_last为零。</p> <ol start="8"><li><strong>关键字</strong></li></ol> <p>在promela中，以下标识符用作保留关键字</p> <div class="custom-block warning"><p class="title"></p><div class="language- extra-class"><pre><code>active		assert		atomic		bit
bool		break		byte		chan
d_step		D_proctype	do		else
empty		enabled		fi		full
goto		hidden		if		init
int		len		mtype		nempty
never		nfull		od		of
pc_value	printf		priority	proctype
provided	run		short		skip
timeout		typedef		unless		unsigned
xr		xs
</code></pre></div></div><h3 id="_5-4-语句"><a href="#_5-4-语句" class="header-anchor">#</a> 5.4 语句</h3> <ol><li><strong>注释</strong>：注释以/*开始，以*/结束。注释不能嵌套。</li> <li><strong>表达式</strong></li></ol> <p>以下运算符和函数可用于构建表达式：</p> <div class="custom-block warning"><p class="title"></p><div class="language- extra-class"><pre><code>+	-	*	/	%	&gt;
&gt;=	&lt;	&lt;=	==	!=	!
&amp;	||	&amp;&amp;	|	~	&gt;&gt;
&lt;&lt;	^	++	--
len()	empty()	nempty()	nfull()	full()
run	eval()	enabled()	pc_value()
</code></pre></div></div><p>        大多数运算符都是二元的，其中逻辑否(!)和减号(-)运算符可以是一元和二元运算符，具体取决于上下文。++和--运算符是一元后缀运算符，就像它们在C中定义的一样。异或用运算符^。<font color="red">倒数第二行的函数是一元的，仅适用于消息通道</font>；len函数返回一个已有通道中的消息数量；其他通道算子的含义跟函数名字表达的预期意义是一致的，<font color="red">主要用于辅助偏序规约</font>。<font color="red">这些函数不能用于更大的表达式</font>。例如，!empty(q)将导致语法错误，应使用nempty(q)代替。最后一行的一元函数很特殊。第一个运算符用于进程实例化，执行时，返回它创建的实例编号。前四行的操作符与在C中的定义是相似的。Promela遵循C的约定，即布尔常量的false对应于值 0；任何非零值都表示true。</p> <ol start="3"><li><strong>条件表达式</strong></li></ol> <p><code>(expr1 -&gt; expr2 : expr3)</code>：如果expr1成立，则返回expr2，否则返回expr3。注意-&gt;在这里是必须的，不能用;代替。</p> <ol start="4"><li><strong>语句</strong></li></ol> <p>以下可以用作语句：</p> <div class="custom-block warning"><p class="title"></p><div class="language- extra-class"><pre><code>declaration	expression	assignment	assert
send 		receive		selection	else
repetition	break		goto		skip
atomic 		timeout		unless		d_step
</code></pre></div></div><p>        语句由分号(;)或等效的箭头(-&gt;)分隔。-&gt;有时表示连续语句之间的蕴含关系，也用于在选择和重复语句中将条件语句和它所保护的语句分开。没有更小的语句作为组成部分的语句称为基本语句。例如，赋值是基本语句，而选择不是。</p> <ol start="5"><li><strong>语句的可执行性</strong></li></ol> <p>        语句要么可执行要么被阻塞。在上面列出的语句中，declarations、assignments、assert、goto、break和skip语句始终可执行。对expression，该expression可执行当且仅当其计算结果非零。对send和receive，该语句可执行当且仅当具备send和receive的条件。例如send要求相应的存储通道没有满，receive要求相应的存储通道不为空，同步通信要求send和receive同时成立。对selection和repetition语句，要求其所有选项中至少有一个可执行。如果语句被阻塞，则程序执行到该点时将暂停，直到该语句可执行。</p> <p>例：相比于写一个繁忙的等待循环<code>while(a != b) skip</code> ，在Promela中使用<code>(a == b)</code>语句可以实现相同的效果。</p> <ol start="6"><li><strong>断言</strong></li></ol> <p><code>assert(expression)</code>：如果expression返回false，则中止程序；否则继续执行。</p> <ol start="7"><li><strong>原子块</strong></li></ol> <p><code>atomic{statements}</code></p> <p>        原子块语句在执行过程中不能被其他进程打断。将局部计算原子化可以显著降低验证的复杂性。在其执行期间，只能通过goto语句或者当其语句被阻塞时才会跳转到原子语句的范围之外。如果该语句随后再次变为可执行状态，则可以在该点继续执行。由run语句激活的进程实例的主体被认为在执行激活的原子语句的范围之外。</p> <ol start="8"><li><strong>Skip语句</strong></li></ol> <p>空语句，主要用于满足句法要求。</p> <ol start="9"><li><strong>Timeout语句</strong></li></ol> <p>当系统中所有其他语句都被阻塞时，就会使能timeout语句。执行时没有效果。</p> <ol start="10"><li><strong>Unless语句</strong></li></ol> <p><code>{statements1} unless {statements2}</code></p> <p>        从statements1开始执行，在执行statements1中检查statements2是否使能，如果是，则中止statements1的执行并将控制转移到statements2；否则继续执行statements1。如果statements1终止，则statements2被忽略。</p> <p>        在unless中，d_step与atomic相比，被认为是不可分割的；即，如果statements1中的控制位于d_step的范围内，则不会检查statements2的启用性。</p> <ol start="11"><li><strong>确定性步骤</strong></li></ol> <p><code>d_step{statements}</code></p> <p>        与atomic具有相同的效果，但效率更高。但是，其范围内的statements必须是完全确定的；它们可能不会跳转到d_step范围之外的标签；可能没有从外部跳转到其范围内的标签；不允许远程引用。最后，第一个以外的语句可能不会阻塞。如果其第一个语句被启用，则整个d_step被启用。<font color="red">Promela认为d_step前面的位置在其范围内，而在其最后一条语句之后的位置则不在其范围内</font>。</p> <p>如：下面的代码达不到预期效果</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">goto</span> label<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
label<span class="token operator">:</span>
	d_step <span class="token punctuation">{</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token keyword">do</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		od
	<span class="token punctuation">}</span>
</code></pre></div><p>正确的代码是：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">goto</span> label<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
label<span class="token operator">:</span> skip<span class="token punctuation">;</span>
	d_step <span class="token punctuation">{</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token keyword">do</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	od<span class="token punctuation">;</span> skip
	<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-5-控制语句"><a href="#_5-5-控制语句" class="header-anchor">#</a> 5.5 控制语句</h3> <ol><li><strong>选择</strong></li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span>
<span class="token operator">::</span> statements
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">::</span> statements
fi
</code></pre></div><p>        一条选择语句中可能会包含多个选项，每个选项都以::开头。选择语句将从其所有选项中选择一个可执行的选项执行。<font color="red">一个选项可以被选择执行要求其第一条语句是使能的。如果有多个选项可供选择，则随机选择一个选项执行</font>。在选择和重复语句中通常用-&gt;符号将条件语句和它所保护的语句分开。此时，-&gt;符号仅仅是起到分隔的作用。若所有选项都不可执行，则该选择语句会阻塞，直到至少有一个可选择的分支。Else语句可以在selection和repetition语句中使用，并在所有其他条件都不成立是使能。</p> <p>例：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span>
<span class="token operator">::</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> option1
<span class="token operator">::</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> option2
fi
</code></pre></div><ol start="2"><li><strong>循环</strong></li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">do</span>
<span class="token operator">::</span> statements
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">::</span> statements
od
</code></pre></div><p>        类似于选择，循环语句也包含多个选项，该语句重复选择其中的可执行选项执行，直到通过goto或break显式跳转到语句之外。break将最里层的重复语句，并且不能在重复之外使用。</p> <ol start="3"><li><strong>无条件跳转</strong></li></ol> <ul><li>标签：同C语言的标签，标签是后面跟冒号(:)的标识符。任何语句都可以被标记。</li> <li>Goto语句：<code>goto label</code>将控制转移到label标记的语句，该语句必须在与goto相同的过程中发生。</li></ul> <h3 id="_5-6-执行promela系统"><a href="#_5-6-执行promela系统" class="header-anchor">#</a> 5.6 执行Promela系统</h3> <p>        Promela系统的系统状态包括全局变量的值、通道缓冲区的内容，以及每个进程实例的位置计数器、局部变量和局部通道缓冲区的值。如果存在never claim，则还包括never claim的位置计数器的值。</p> <p>        初始时，所有未初始化全局变量的值都为0，所有通道缓冲区为空。系统进程实例包括通过proctype上的active修饰符创建的进程，以及init和never进程（如果存在）。这些进程实例的位置计数器位于它们的第一个语句处。</p> <p>        Promela系统的系统状态唯一标识每个（活动）进程实例中使能的语句。一个不包含never claim的系统通过任意选择执行一条使能的语句来执行一步，然后进入一个新的系统状态。因此，进程是异步执行的。但是，如果所选语句是无缓冲的发送（接收），则需要同时执行相应的接收（发送）语句。</p> <p>        如果系统包含一个 never claim，则一个执行步骤是一个组合的、同步的步骤：从 never 声明中执行一条（使能的）语句，并执行系统其余部分的一个步骤。因此，在never claim没有语句使能的情况下（在当前状态下），never claim会阻塞系统的执行。</p> <p>        Promela系统的执行序列或行为是一条执行步骤的最大（可能无限）序列，<font color="green">其中第一个不走取自初始系统状态</font>。</p> <ul><li><strong>Atomic语句和d_step语句</strong></li></ul> <p>        atomic语句和d_step限制系统执行其他地方的语句，因为它们（原则上）作为单个基本语句执行。因此，在存在never claim的情况下，系统的执行步骤将 never claim中的单个步骤与atomic语句或d_step的执行序列相结合。</p> <ul><li><strong>分析</strong></li></ul> <p>        可以对Promela系统进行精确（但有效）分析是否存在正确性违反：即，是否存在通过断言中止的执行序列；该序列以无效的结束状态结束；以及是否存在满足通过never-claims定义的线性时序逻辑规约。</p> <ul><li><strong>结束状态</strong></li></ul> <p>有效结束状态：每个进程都已到达其程序主体的末尾或者进入带有前缀end开头的标签语句处的系统状态。</p> <p>无效的最终状态：除有效结束状态之外的状态。</p> <p>严格来说，有效的最终状态也应该要求通道是空的。可通过<code>Spin的-q</code>选项要求最终状态时所有通道都是空的。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2022/11/1 23:39:55</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vuepress-notes/article/article002/" class="prev">
          模型检验理论
        </a></span> <span class="next"><a href="/vuepress-notes/tool/nusmv/">
          NuSMV
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_1-什么是spin" class="sidebar-link reco-side-_1-什么是spin" data-v-b57cc07c>1. 什么是Spin</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_2-spin功能特性" class="sidebar-link reco-side-_2-spin功能特性" data-v-b57cc07c>2. Spin功能特性</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_3-spin的四种主要使用模式" class="sidebar-link reco-side-_3-spin的四种主要使用模式" data-v-b57cc07c>3. Spin的四种主要使用模式</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_4-spin的下载安装" class="sidebar-link reco-side-_4-spin的下载安装" data-v-b57cc07c>4. Spin的下载安装</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_4-1-spin的下载安装" class="sidebar-link reco-side-_4-1-spin的下载安装" data-v-b57cc07c>4.1 Spin的下载安装</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_4-2-ispin的下载安装" class="sidebar-link reco-side-_4-2-ispin的下载安装" data-v-b57cc07c>4.2 iSpin的下载安装</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_4-3-ispin的使用" class="sidebar-link reco-side-_4-3-ispin的使用" data-v-b57cc07c>4.3 iSpin的使用</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-基于promela的系统建模" class="sidebar-link reco-side-_5-基于promela的系统建模" data-v-b57cc07c>5. 基于Promela的系统建模</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-1-进程" class="sidebar-link reco-side-_5-1-进程" data-v-b57cc07c>5.1 进程</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-2-消息通道" class="sidebar-link reco-side-_5-2-消息通道" data-v-b57cc07c>5.2 消息通道</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-3-数据定义" class="sidebar-link reco-side-_5-3-数据定义" data-v-b57cc07c>5.3 数据定义</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-4-语句" class="sidebar-link reco-side-_5-4-语句" data-v-b57cc07c>5.4 语句</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-5-控制语句" class="sidebar-link reco-side-_5-5-控制语句" data-v-b57cc07c>5.5 控制语句</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-notes/tool/spin/#_5-6-执行promela系统" class="sidebar-link reco-side-_5-6-执行promela系统" data-v-b57cc07c>5.6 执行Promela系统</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/vuepress-notes/bgm/1.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/vuepress-notes/bgm/1.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/vuepress-notes/bgm/1.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>世面</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>周林</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/vuepress-notes/assets/js/app.80219140.js" defer></script><script src="/vuepress-notes/assets/js/3.4410d185.js" defer></script><script src="/vuepress-notes/assets/js/1.04063a12.js" defer></script><script src="/vuepress-notes/assets/js/19.5ee5dec0.js" defer></script>
  </body>
</html>
